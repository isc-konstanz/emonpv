#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
    pvforecast
    ~~~~~
    
    

"""
import logging
logger = logging.getLogger('pvforecast')

from argparse import ArgumentParser
from configparser import ConfigParser

import os
import datetime
import pvforecast as pv

from pvforecast import ModelChain
from pvlib.location import Location


def main():
    logger.info('Starting pvforecast')
    args = _get_parser().parse_args()
    
    configdir = args.configdir
    logger.debug('Configurations will be read in from "%s"', configdir)
    
    model = args.model
    logger.debug('Weather model to be used: "%s"', model)
    
    configfile = os.path.join(configdir, 'systems.cfg')
    settingsfile = os.path.join(configdir, 'settings.cfg')
    configs = ConfigParser()
    settings = ConfigParser()
    configs.read(configfile)
    settings.read(settingsfile)
    sys_config = pv.system.read(configdir)
    
    runFlag = False
    try:
        for sys in configs:
            if sys != 'DEFAULT':
                tz = configs.get(sys,'timezone')
                longitude = float(configs.get(sys,'longitude'))
                latitude = float(configs.get(sys,'latitude'))
                altitude = float(configs.get(sys,'altitude'))
                date = datetime.datetime.now()
                
                authKey = settings.get('Auth', 'key')
                #check for update
                is_new, run = pv.weather.check_update(authKey, date, tz, longitude, latitude, method=model)
                if(is_new or runFlag):
                    runFlag = True
                    forecast = pv.weather.forecast(date, tz, longitude, latitude, method=model, authKey=authKey)
                    
                    if not forecast.empty:
                        system = pv.system.configure(sys, sys_config[sys])
                        
                        # use a ModelChain object to calculate modeling intermediates
                        mc = ModelChain(system, Location(latitude, longitude, tz, altitude, sys))
                        
                        # extract relevant data for model chain
                        mc.run_model(forecast.index, weather=forecast);
                        
                        yieldprediction = mc.ac
                        
                        if yieldprediction.empty:
                            logger.error('PV forecast returned empty')
                        else:
                            filename = './results/'+sys+'_cosmo_de_'+ str(int((run - datetime.datetime(1970,1,1)).total_seconds())) + '_yield.csv';
                            yieldprediction = yieldprediction.to_frame()
                            yieldprediction = yieldprediction.rename(columns= {0: 'power'})
                            yieldprediction.index.name = 'time'
                            yieldprediction.to_csv(filename, sep=',', encoding='utf-8')
                            
                            logger.info('PV forecast successfully saved as "%s"', filename)
                    else:
                        logger.error('Parsed weather forecast "%s" was empty', forecast.key)
                        
    except IOError as e:
        logger.error('Error while running pvforecast: %s', e.message)


def _get_parser():
    parser = ArgumentParser(description=__doc__)
    here = os.path.abspath(os.path.dirname(__file__))
    
    parser.add_argument('-c','--config',
                        dest='configdir',
                        help="Directory of system configuration files",
                        defaut=os.path.join(os.path.dirname(here), 'conf'),
                        metavar='DIR')
    parser.add_argument('-m','--model',
                        dest='model',
                        help="The weather model which will be used",
                        choices=['COSMO_DE', 'ICON_EU'],
                        default='COSMO_DE')
    
    return parser


if __name__ == "__main__":
    main()
