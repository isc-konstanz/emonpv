#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
    pveffsimulation
    ~~~~~
    
    This command line script simulates the efficiency optimization for a generation 
    prediction of photovoltaic systems. The prediction will be based over a whole
    period of succeeding daily weather forecast files in a defined directory.
    
    To learn how to configure specific settings, see "pveffsimulation --help"
    
"""
import logging
logger = logging.getLogger('pveffsimulation')

import os
import datetime
from pytz import AmbiguousTimeError
from configparser import ConfigParser

import numpy as np
import pandas as pd
import pvprediction as pv
from pvprediction.emoncms import Emoncms


def main(args=None):
    logger.info('Starting pveffsimulation')
    
    here = os.path.abspath(os.path.dirname(__file__))
    args = _get_parser().parse_args()
    
    if (args.configdir != None):
        configdir = args.configdir
        logger.debug('PV system configurations will be read in from "%s"', configdir)
    else:
        configdir = os.path.join(os.path.dirname(here), 'conf')
    
    settingsfile = os.path.join(configdir, 'settings.cfg')
    settings = ConfigParser()
    settings.read(settingsfile)
    
    if (args.weatherdir != None):
        weatherdir = args.weatherdir
        logger.debug('Weather forecast data will be read in from "%s"', weatherdir)
    else:
        weatherdir = str(settings.get('General','datadir'))
    
    if not os.path.exists(weatherdir):
        logger.error('The specified directory "%s" does not exist', weatherdir)
        quit()
    
    if (args.simdir != None):
        simdir = args.simdir
        logger.debug('Simulation results will be saved in "%s"', simdir)
    else:
        simdir = str(settings.get('General','datadir'))
    
    if not os.path.exists(simdir):
        os.makedirs(simdir)
    
    emoncms = Emoncms(settings.get("Emoncms","URL"), settings.get("Emoncms","APIkey"))
    
    systems = pv.system.read(configdir)
    
    # Look for the earliest forecast available in the weather directory
    forecast = pv.weather.forecast(datetime.datetime(1970, 1, 1), settings.get('Location','timezone'), 
                                   var=weatherdir, method='DWD_CSV')
    
    # Retrieve measured solar irradiation values to use as a reference for
    # the optimizations prediction error if necessary
    if args.method_ref == 'reference':
        dwd_meas = pv.weather.reference(datetime.datetime.now(), 
                                        settings.get('Location','timezone'), 
                                        var=settings.get("DWD","id"), 
                                        method='DWD_PUB')
    
    # Prepare DataFrames to collect several prior days to optimize with, 
    # if the static optimization method was selected
    if args.method_opt == 'static':
        transitions = pd.DataFrame()
        references = pd.DataFrame()
    
    reference = pd.DataFrame()
    measurements = pd.Series(np.nan, name='measurements')
    
    time = forecast.index[0]
    running = True
    while running:
        time = time + datetime.timedelta(days=1)
        forecast = _parse_forecasts(time, weatherdir, settings.get('Location','timezone'))
        
        # When the specified file does not exist, the closest one to the passed 
        # date will be returned
        if forecast.index[0] != time:
            running = False
            logger.info('Simulation ended with "%s" as the last forecast found', forecast.key)
            
        else:
            logger.info('Starting optimized prediction for forecast: %s', forecast.key)
            for sysid, sys in systems.items():
                times = forecast.index - datetime.timedelta(days=1)
                try:
                    # Reference values are retrieved of one single file, providing data over several months
                    if args.method_ref == 'reference' and (reference.empty or not reference.index.equals(times)):
                        reference = dwd_meas[(dwd_meas.index >= times[0] - datetime.timedelta(minutes=30)) & 
                                             (dwd_meas.index <= times[-1] + datetime.timedelta(minutes=30))]
                        reference.key = sysid + '_dwd'
                    
                    # The measurements for the next day will already be retrieved for comparison and only
                    # needs to be requested once in the beginning and after failures
                    if measurements.empty or not measurements.index.equals(times):
                        measurements = emoncms.feed('device' + sys.id.lower() + '_out_power', times, settings.get('Location','timezone'))
                        measurements.name = 'measurements'
                    
                    # If the measurements are still empty, an error occurred and will be logged
                    if not measurements.empty and (measurements > 0).any() and measurements.index.equals(times):
                        if not args.method_opt:
                            result = sys.system_param['eta']
                            
                        elif args.method_opt == 'recursive':
                            result = _optimize_rec(times[0], sys, settings, weatherdir, 
                                                   measurements, reference=reference, 
                                                   method=args.method_ref)
                            
                        elif args.method_opt == 'static':
                            result, transitions, references = _optimize_static(times[0], sys, settings, weatherdir, 
                                                                               measurements, transitions, references, reference=reference, 
                                                                               method=args.method_ref)
                        
                        eta = pd.Series(np.nan, index=forecast.index, name='eta')
                        for i in eta.index:
                            eta.ix[i] = result[i.tz_convert('UTC').hour]
                        
                        measurements = emoncms.feed('device' + sys.id.lower() + '_out_power', forecast.index, settings.get('Location','timezone'))
                        measurements.name = 'measurements'
                        
                        
                        if not measurements.isnull().any():
                            filename = forecast.key + '_opt_' + sysid + '.csv';
                            filepath = os.path.join(simdir, filename)
                            
                            est = pv.predict.power_effective(sys, forecast.calculate(sys), forecast.temperature)*eta*sys.modules_param['n']
                            est.name = 'estimation'
                            
                            if not est.isnull().any():
                                logger.debug('PV prediction successful and saved as "%s"', filename)
                            
                                e_est = pd.Series(est - measurements, name='e_est')
                                e_rel_est = (e_est/measurements).replace(np.inf,0).replace(-np.inf,0).fillna(0)*100
                                
                                if args.method_ref == 'reference':
                                    reference = dwd_meas[(dwd_meas.index >= forecast.index[0] - datetime.timedelta(minutes=30)) & 
                                                         (dwd_meas.index <= forecast.index[-1] + datetime.timedelta(minutes=30))]
                                    reference.key = sysid + '_dwd'
                                     
                                    ref = pv.predict.power_effective(sys, reference.calculate(sys), reference.temperature.dropna()).dropna()*eta*sys.modules_param['n']
                                    ref.name = 'reference'
                                    
                                    e_ref = pd.Series(ref - measurements, name='e_ref')
                                    e_rel_ref = (e_ref/measurements).replace(np.inf,0).replace(-np.inf,0).fillna(0)*100
                                    
                                    sim = pd.concat([measurements, est, ref, e_est, e_ref], axis=1)
                                
                                else:
                                    sim = pd.concat([measurements, est, e_est], axis=1)
                                    
                                sim.to_csv(filepath, sep=',', encoding='utf-8')
                                
                                
                                if not args.method_ref is None:
                                    _concat_file(os.path.join(simdir, 'efficiency.csv'), eta, forecast.key)
                                
                                _concat_file(os.path.join(simdir, 'innovation.csv'), e_est, forecast.key)
                                _concat_file(os.path.join(simdir, 'error.csv'), e_rel_est, forecast.key)
                                
                                if args.method_ref == 'reference':
                                    _concat_file(os.path.join(simdir, 'innovation_ref.csv'), e_ref, forecast.key)
                                    _concat_file(os.path.join(simdir, 'error_ref.csv'), e_rel_ref, forecast.key)
                                    
                    else:
                        logger.warn('Unable to find valid measurements for the %s', times[0].strftime('%d. %b %Y'))
                
                except AmbiguousTimeError:
                    # AmbiguousTimeError will be thrown for some pandas version, if a daylight savings time crossing gets converted
                    logger.warn('Error retrieving measurement data due to daylight savings timestamps for forecast: %s', forecast.key)


def _optimize_rec(time, system, settings, weatherdir, measurements, reference=None, method=None):
    power_eff = None
    if method == 'forecast':
        forecast_prior = _parse_forecasts(time, weatherdir, settings.get('Location','timezone'))
        power_eff = pv.predict.power_effective(system, forecast_prior.calculate(system), forecast_prior.temperature)*system.modules_param['n']
    
    elif method == 'reference':
        power_eff = pv.predict.power_effective(system, reference.calculate(system), reference.temperature.dropna()).dropna()*system.modules_param['n']
    
    eta = pv.predict.optimize(system, power_eff, measurements,  
                              float(settings.get('Optimization','forgetting')))
    
    return eta


def _optimize_static(time, system, settings, weatherdir, measurements, transitions, references, reference=None, method=None):
    if not measurements.isnull().any():
        # Drop data from the collected transition and reference DataFrames, if they are 
        # older than the specified amount of days in the settings file
        earliest = time - datetime.timedelta(days=int(settings.get('Optimization','days')))
        if not transitions.empty and transitions.columns[0] < earliest:
            transitions = transitions.drop(transitions.columns[0], axis=1)
        if not references.empty and references.columns[0] < earliest:
            references = references.drop(references.columns[0], axis=1)
        
        # Add the new measurements to the collected measurement DataFrame
        meas = measurements.copy()
        meas.name = meas.index[0]
        meas.index = meas.index.hour
        references = pd.concat([references, meas.groupby(meas.index).first()], axis=1)
        
        power_eff = None
        if method == 'forecast':
            forecast_prior = _parse_forecasts(time, weatherdir, settings.get('Location','timezone'))
            power_eff = pv.predict.power_effective(system, forecast_prior.calculate(system), forecast_prior.temperature)*system.modules_param['n']
        
        elif method == 'reference':
            power_eff = pv.predict.power_effective(system, reference.calculate(system), reference.temperature.dropna()).dropna()*system.modules_param['n']
        
        # Add the new transition column to the collected transitions DataFrame
        power_eff.name = power_eff.index[0]
        power_eff.index = power_eff.index.hour
        transitions = pd.concat([transitions, power_eff.groupby(power_eff.index).first()], axis=1)
        
        eta = pv.predict.optimise_static(system, transitions, references)
    else:
        eta = system.system_param['eta']
    
    return eta, transitions, references


def _parse_forecasts(time, path, timezone):
    forecast = pv.weather.forecast(time, timezone, var=path, method='DWD_CSV')
    
    # As with a new forecast every 6 hours, taking only the first 6 hours
    # of a forecast will reduce inaccuracies, which increase with the amount
    # of time looked into the future
    result = forecast[0:6]
    for i in range(1,4):
        t = time + datetime.timedelta(hours=6*i)
        f = pv.weather.forecast(t, timezone, var=path, method='DWD_CSV')
        if f.empty or f[0:6].isnull().any(axis=1).any() or f.index[0] != t:
            f = forecast[t:]
        
        result = pd.concat([result, f[0:6]], axis=0)
    
    result.key = forecast.key
    return result


def _concat_file(filename, series, key):
    if not series.isnull().any() and np.count_nonzero(series)/float(len(series)) > 0.3:
        if os.path.isfile(filename):
            csv = pd.read_csv(filename, index_col='hours', encoding='utf-8')
        else:
            csv = pd.DataFrame()
        series.name = key
        series.index = series.index.hour
        series.index.name = 'hours'
        
        # Concat series to existing file and check for duplicate index
        csv = pd.concat([csv, series.groupby(series.index).first()], axis=1).fillna(0)
        csv.to_csv(filename, sep=',', encoding='utf-8')


def _get_parser():
    from argparse import ArgumentParser
    
    parser = ArgumentParser(description=__doc__)
    
    parser.add_argument('-c','--config', 
                        dest='configdir',
                        help='Directory of system configuration files', 
                        metavar='DIR')
    parser.add_argument('-w','--weather', 
                        dest='weatherdir',
                        help='Directory of solar irradiance and temperature files', 
                        metavar='DIR')
    parser.add_argument('-s','--simulation', 
                        dest='simdir',
                        help='Directory in which simulation output files will be placed', 
                        metavar='DIR')
    parser.add_argument('-m','--method', 
                        dest='method_opt',
                        default='recursive',
                        help='The optimization method can be chosen either "recursive" or "static"')
    parser.add_argument('-r','--reference', 
                        dest='method_ref',
                        default='forecast',
                        help='The reference method can be chosen either "forecast" or "reference"')
    
    return parser


if __name__ == '__main__':
    main()