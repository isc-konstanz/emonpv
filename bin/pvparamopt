#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""    
    Optimises the prediction parameters of a photovoltaic energy systems, according to solar irradiance forecasts
    
"""
import os
import numpy as np
import pandas as pd
import pvprediction as pv
from configparser import ConfigParser


def main(args=None):
    here = os.path.abspath(os.path.dirname(__file__))
    args = get_parser().parse_args()
    
    if (args.forecastfile != None):
        forecastloc = args.forecastfile
    elif (args.forecastdir != None):
        forecastloc = args.forecastdir
    else:
        here = os.path.abspath(os.path.dirname(__file__))
        forecastloc = os.path.join(os.path.dirname(here), 'forecast')
    
    settingsfile = os.path.join(os.path.dirname(here), 'conf', 'settings.cfg')
    settings = ConfigParser()
    settings.read(settingsfile)
    if(os.path.isdir(forecastloc)):
        forecastfile = get_forecastfile(forecastloc, settings.get("Location","key"))
    else:
        forecastfile = forecastloc
    
    forecast_csv = pd.read_csv(forecastfile, 
                            usecols=['time','aswdifd_s','aswdir_s','t_2m','t_g'], 
                            index_col='time', parse_dates=['time'])
    forecast = forecast_csv.ix[:,:'t_2m'].rename(columns = {'aswdir_s':'direct', 'aswdifd_s':'diffuse', 't_2m':'temperature'})
    forecast.index = forecast.index.tz_localize('UTC').tz_convert(settings.get('Location','timezone'))
    
    
    systemlist = pv.systems.read(float(settings.get('Location','latitude')), 
                                 float(settings.get('Location','longitude')), 
                                 float(settings.get('Location','altitude')),
                                 str(settings.get('Location','timezone')))
    
    for id, sys in systemlist.items():
        result = pv.optimise.parameters(sys, forecast)
        result = result.drop(result.columns[0], axis=1)
        result = result.dropna()
        
        if (args.outputdir != None):
            outputdir = args.outputdir
            
            simulationname = os.path.basename(forecastfile).replace('.csv', '_Optimisation_') + id + '.csv';
            simulationfile = os.path.join(outputdir, simulationname)
            
            result.to_csv(simulationfile, sep=',', encoding='utf-8')
    
    
def get_forecastfile(dir, key):
    forecastfile = None   
    try:
        for file in os.listdir(dir):
            if (key + '_' in file) and (file.endswith('.csv')):
                if (forecastfile == None) or (file[3:-4] > forecastfile[3:-4]):
                    forecastfile = file
    except IOError:
        print("Error: unable to read irradiance forecast file in \"{}\"".format(dir))
    else:
        if(forecastfile == None):
            raise IOError("Unable to find irradiance forecast files in \"{}\"".format(dir))
        else:
            return os.path.join(dir, forecastfile)
        

def get_parser():
    from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
    
    parser = ArgumentParser(description=__doc__)
    
    parser.add_argument('-f','--file', 
                        dest='forecastfile',
                        type=lambda x: is_valid_file(parser, x),
                        help="Location of a solar irradiance forecast csv file to be processed", 
                        metavar='CSV')
    parser.add_argument('-d','--dir', 
                        dest='forecastdir',
                        help="Directory of solar irradiance forecast csv files, of which the newest one will be processed", 
                        metavar='DIR')
    parser.add_argument('-o','--output', 
                        dest='outputdir',
                        help="Directory in which optimisation detail csv files will be placed", 
                        metavar='DIR')
    return parser


def is_valid_file(parser, arg):
    """
        Check if arg is a valid file that already exists on the file
        system.
        
    """
    arg = os.path.abspath(arg)
    if not os.path.exists(arg):
        parser.error("The file %s does not exist!" % arg)
    else:
        return arg


if __name__ == "__main__":
    main()