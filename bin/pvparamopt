#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""    
    Optimises the prediction parameters of a photovoltaic energy systems, according to solar irradiance forecasts
    
"""
import os
import numpy as np
import pandas as pd
import pvprediction as pv
from pvprediction import Emoncms
from configparser import ConfigParser


def main(args=None):
    here = os.path.abspath(os.path.dirname(__file__))
    args = get_parser().parse_args()
    
    if (args.forecastfile != None):
        forecastloc = args.forecastfile
    elif (args.forecastdir != None):
        forecastloc = args.forecastdir
    else:
        here = os.path.abspath(os.path.dirname(__file__))
        forecastloc = os.path.join(os.path.dirname(here), 'forecast')
    
    settingsfile = os.path.join(os.path.dirname(here), 'conf', 'settings.cfg')
    settings = ConfigParser()
    settings.read(settingsfile)
    if(os.path.isdir(forecastloc)):
        forecastfile = get_forecastfile(forecastloc, settings.get("Location","key"))
    else:
        forecastfile = forecastloc
        
    forecast_csv = pd.read_csv(forecastfile, 
                            usecols=['time','aswdifd_s','aswdir_s','t_2m','t_g'], 
                            index_col='time', parse_dates=['time'])
    forecast = forecast_csv.ix[:,:'t_2m'].rename(columns = {'aswdir_s':'direct', 'aswdifd_s':'diffuse', 't_2m':'temperature'})
    forecast.index.tz_localize('UTC').tz_convert(settings.get('Location','timezone'))
    
    
    emoncms = Emoncms(settings.get("Emoncms","URL"), settings.get("Emoncms","APIkey"))
    
    
    systemlist = pv.systems.read(settings.get('Location','latitude'), 
                              settings.get('Location','longitude'), 
                              settings.get('Location','timezone'))
        
    for id, sys in systemlist.items():
        # Bad style of hardcoded 3min feed interval. Needs to be redone
        timestamps = forecast.index.astype(np.int64)//10**6
        interval = 3*60*1000
        # Offset start and end by 3min, to compensate possible emoncms time offsets
        step = timestamps[1] -  timestamps[0]
        start = timestamps[0] - step
        end = timestamps[-1] + step
        datapoints = int((end - start)/interval)
        
        measurements = emoncms.feed(id.lower() + '_out_power', start, end, datapoints)
        measurements = measurements.ix[start:end]
        measurements.index = pd.to_datetime(measurements.index,unit='ms')
        measurements.index.tz_localize('UTC').tz_convert(settings.get('Location','timezone'))
        
        # Average +/- 30min, to get hourly reference values
        reference = pd.Series(np.nan, index=forecast.index, name='reference')
        for time in forecast.index:
            start = time + pd.DateOffset(minutes=-30)
            end = time + pd.DateOffset(minutes=30)
            test = measurements.ix[start:end].values
            reference.ix[time] = test.mean()
        
        estimate = pv.optimisation.systemsparam(sys, forecast, reference)
        
        result = pd.concat([measurements, reference, estimate], axis=1)
        
        if (args.outputdir != None):
            outputdir = args.outputdir
            
            simulationname = os.path.basename(forecastfile).replace('.csv', '_Optimisation_') + id + '.csv';
            simulationfile = os.path.join(outputdir, simulationname)
            
            result.to_csv(simulationfile, sep=',', encoding='utf-8')
    
    
def get_forecastfile(dir, key):
    forecastfile = None   
    try:
        for file in os.listdir(dir):
            if (key + '_' in file) and (file.endswith('.csv')):
                if (forecastfile == None) or (file[3:-4] > forecastfile[3:-4]):
                    forecastfile = file
    except IOError:
        print("Error: unable to read irradiance forecast file in \"{}\"".format(dir))
    else:
        if(forecastfile == None):
            raise IOError("Unable to find irradiance forecast files in \"{}\"".format(dir))
        else:
            return os.path.join(dir, forecastfile)
        

def get_parser():
    from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
    
    parser = ArgumentParser(description=__doc__)
    
    parser.add_argument('-f','--file', 
                        dest='forecastfile',
                        type=lambda x: is_valid_file(parser, x),
                        help="Location of a solar irradiance forecast csv file to be processed", 
                        metavar='CSV')
    parser.add_argument('-d','--dir', 
                        dest='forecastdir',
                        help="Directory of solar irradiance forecast csv files, of which the newest one will be processed", 
                        metavar='DIR')
    parser.add_argument('-o','--output', 
                        dest='outputdir',
                        help="Directory in which optimisation detail csv files will be placed", 
                        metavar='DIR')
    return parser


def is_valid_file(parser, arg):
    """
        Check if arg is a valid file that already exists on the file
        system.
        
    """
    arg = os.path.abspath(arg)
    if not os.path.exists(arg):
        parser.error("The file %s does not exist!" % arg)
    else:
        return arg


if __name__ == "__main__":
    main()